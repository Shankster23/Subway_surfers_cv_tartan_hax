<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Rail Rush 3D - Motion Control</title>
  <style>
    /* Reset & Base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a0a12
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: monospace
    }

    #g {
      background: #1a1a2e;
      width: 100%;
      height: 100%
    }

    /* --- Top Header Bar --- */
    #topBar {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px 16px;
      /* Safe area padding */
      padding-top: max(12px, env(safe-area-inset-top));
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(to bottom, rgba(10, 10, 18, 0.8), rgba(10, 10, 18, 0));
      z-index: 100;
      pointer-events: none;
      /* Let clicks pass through empty areas */
    }

    #topBar>* {
      pointer-events: auto;
    }

    /* Re-enable clicks on buttons */

    /* Top Left Group: Help */
    #topLeft {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* Top Center Group: Score */
    #topCenter {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    /* Top Right Group: Stats & Settings */
    #topRight {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* Buttons & HUD Items */
    .hudBtn {
      background: rgba(255, 215, 0, 0.15);
      border: 2px solid rgba(255, 215, 0, 0.3);
      color: #ffd700;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }

    .hudBtn:active {
      transform: scale(0.95);
    }

    /* Score Display */
    #sc {
      font-size: 24px;
      font-weight: bold;
      color: #ffd700;
      letter-spacing: 2px;
      font-variant-numeric: tabular-nums;
      -webkit-text-stroke: 1px rgba(0, 0, 0, 0.5);
    }

    #hscDisplay {
      font-size: 10px;
      color: #ccc;
      margin-top: -2px;
    }

    /* Coins & Lives */
    #statsRow {
      display: flex;
      gap: 12px;
      font-size: 14px;
      font-weight: bold;
      color: #ffd700;
    }

    .statItem {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .coinIcon {
      width: 14px;
      height: 14px;
      background: radial-gradient(circle at 30% 30%, #ffe066, #ffd700, #b8860b);
      border-radius: 50%;
      border: 1px solid #b8860b;
    }

    .heartIcon {
      color: #ff4757;
      font-size: 14px;
    }

    /* --- Center / Overlay UI --- */
    #m,
    #ov,
    #pa,
    #help,
    #calibrate {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(10, 10, 18, 0.95);
      padding: 24px;
      border-radius: 16px;
      border: 2px solid #ffd700;
      color: #fff;
      text-align: center;
      z-index: 150;
      min-width: 280px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    #m {
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
      top: 40%;
    }

    #m h1 {
      font-size: 28px;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #ffd700, #ff6b6b, #ffd700);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      white-space: nowrap;
    }

    #m p {
      color: #ccc;
      font-size: 12px;
      margin-bottom: 20px;
      line-height: 1.5;
    }

    #st {
      padding: 14px 40px;
      font-size: 18px;
      font-weight: bold;
      background: linear-gradient(135deg, #ffd700, #ff8c00);
      border: none;
      border-radius: 30px;
      color: #1a1a2e;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }

    /* Game Over & Pause */
    h2 {
      color: #ffd700;
      font-size: 22px;
      margin-bottom: 16px;
    }

    .b {
      background: rgba(255, 215, 0, 0.15);
      border: 2px solid rgba(255, 215, 0, 0.3);
      color: #ffd700;
      padding: 10px 24px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: bold;
    }

    #fn {
      font-size: 32px;
      color: #ffd700;
      font-weight: bold;
      margin: 10px 0;
    }

    /* Pause Button (Top Right in Play Mode) */
    #ps {
      display: none;
      margin-left: 10px;
      width: 36px;
      height: 36px;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    /* --- Bottom Area --- */
    #bottomArea {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: auto;
      pointer-events: none;
      z-index: 50;
      padding-bottom: max(10px, env(safe-area-inset-bottom));
    }

    /* Camera View */
    #camWrap {
      position: absolute;
      top: 70px;
      /* Below top bar */
      right: 16px;
      width: 160px;
      display: none;
      z-index: 60;
      pointer-events: auto;
    }

    #cam,
    #pose {
      width: 100%;
      height: 120px;
      border-radius: 8px;
      border: 2px solid #ffd700;
      object-fit: cover;
      transform: scaleX(-1);
      background: #000;
    }

    #pose {
      position: absolute;
      top: 0;
      left: 0;
      background: transparent;
      border: none;
    }

    #zones {
      display: flex;
      height: 16px;
      margin-top: 4px;
      border-radius: 4px;
      overflow: hidden;
    }

    .zone {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      font-weight: bold;
      color: #fff;
    }

    #cvStatus {
      background: rgba(0, 0, 0, 0.6);
      color: #ffd700;
      padding: 4px;
      text-align: center;
      font-size: 10px;
      border-radius: 4px;
      margin-top: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* On-Screen Controls */
    .ct {
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: center;
      pointer-events: auto;
      margin-bottom: 16px;
    }

    .dpad-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.8);
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(4px);
    }

    .dpad-btn:active {
      background: rgba(255, 255, 255, 0.25);
      transform: scale(0.9);
    }

    /* Hidden elements by default */
    #ov,
    #pa,
    #help,
    #calibrate {
      display: none;
    }
  </style>
</head>

<body>
  <canvas id="g"></canvas>

  <!-- Top Header Bar -->
  <div id="topBar">
    <div id="topLeft">
      <button id="helpBtn" class="hudBtn">‚ùì HELP</button>
    </div>

    <div id="topCenter">
      <div id="statsRow">
        <div class="statItem">
          <div class="coinIcon"></div><span id="cn">0</span>
        </div>
        <div class="statItem" id="lv"></div>
      </div>
      <div id="scoreWrap">
        <div id="sc">000000</div>
        <div id="hscDisplay">BEST: 0</div>
      </div>
    </div>

    <div id="topRight">
      <button id="cvToggle" class="hudBtn">üì∑ CV: OFF</button>
      <button id="ps" class="hudBtn">‚è∏</button>
    </div>
  </div>

  <!-- Camera Feed (Top Right) -->
  <div id="camWrap">
    <video id="cam" autoplay playsinline></video>
    <canvas id="pose"></canvas>
    <div id="zones">
      <div class="zone" id="zL" style="background:#3498db">‚óÄ L</div>
      <div class="zone" id="zC" style="background:#27ae60">‚óè M</div>
      <div class="zone" id="zR" style="background:#e74c3c">R ‚ñ∂</div>
    </div>
    <div id="cvStatus">üì∑ Waiting...</div>
  </div>

  <!-- Center Overlays -->
  <div id="m">
    <h1>üöÉ RAIL RUSH 3D üöÉ</h1>
    <p>Run, Jump, Slide & Dodge!<br>Use Swipe, Keys, or Camera Body Control</p>
    <button id="st">TAP TO PLAY</button>
    <div id="calNote" style="font-size:11px;color:#aaa;display:none;margin-top:12px">Finish calibration to start</div>
  </div>

  <div id="ov">
    <h2>üí• BUSTED!</h2>
    <div id="fn">0</div>
    <div id="hsc">Best: 0</div>
    <button class="b" id="rt" style="margin-top:10px">RETRY</button>
  </div>

  <div id="pa">
    <h2>‚è∏ PAUSED</h2>
    <button class="b" id="rs">RESUME</button>
    <button class="b" id="qt"
      style="background:rgba(255,70,70,0.2);border-color:rgba(255,70,70,0.4);color:#ff4757">QUIT</button>
  </div>

  <!-- Bottom Area Container -->
  <div id="bottomArea">
    <!-- Touch Controls -->
    <div class="ct">
      <button class="dpad-btn" id="bl">‚óÄ</button>
      <button class="dpad-btn" id="bu">‚ñ≤</button>
      <button class="dpad-btn" id="bd">‚ñº</button>
      <button class="dpad-btn" id="br">‚ñ∂</button>
    </div>
  </div>

  <div id="help">
    <h2>How to Play</h2>
    <p id="helpText">Swipe/arrows: Left/Right to change lanes, Up to jump, Down to slide.</p>
    <div id="helpNav">
      <button class="b" id="helpPrev"
        style="width:auto;padding:8px 16px;border-radius:12px;font-size:11px">Prev</button>
      <button class="b" id="helpNext"
        style="width:auto;padding:8px 16px;border-radius:12px;font-size:11px">Next</button>
      <button class="b" id="helpClose"
        style="width:auto;padding:8px 16px;border-radius:12px;font-size:11px">Close</button>
    </div>
  </div>

  <!-- Calibration Modal -->
  <div id="calibrate">
    <h2>üì∑ Calibration</h2>
    <p>Stand where the camera can see your upper body</p>
    <div id="calStep">üßç</div>
    <div id="calInstr">Stand in MIDDLE position</div>
    <div id="calProgress">
      <div id="calBar"></div>
    </div>
    <div id="calBtns">
      <button class="b" id="calSkip" style="width:auto;padding:8px 16px;border-radius:12px;font-size:11px">Skip</button>
      <button class="b" id="calReset"
        style="width:auto;padding:8px 16px;border-radius:12px;font-size:11px">Restart</button>
    </div>
  </div>

  <!-- MediaPipe Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

  <script>
    const C = document.getElementById('g'), X = C.getContext('2d'), W = 400, H = 650;
    C.width = W; C.height = H;
    onresize = () => { const r = W / H, wr = innerWidth / innerHeight; let w, h; if (wr > r) { h = innerHeight; w = h * r } else { w = innerWidth; h = w / r } C.style.width = w + 'px'; C.style.height = h + 'px'; document.documentElement.style.setProperty('--gw', w + 'px'); document.documentElement.style.setProperty('--gh', h + 'px') }; onresize();

    const D = 300, GY = 550, HY = 200, LN = [-80, 0, 80];
    const pj = (x, y, z) => { const s = D / (z + D); return { x: W / 2 + x * s, y: HY + (GY - HY - y) * s, s } };

    let st = 'menu', sc = 0, cn = 0, bs = +localStorage.rb3 || 0, lv = 2, pl = { l: 1, tl: 1, lt: 1, y: 0, vy: 0, sl: 0, x: 0 };
    let sp = 6, ob = [], co = [], pt = [], rz = 0, tk = 0, nx = 50, sh = 0, ky = {}, tc = { sx: 0, sy: 0, x: 0, y: 0, on: 0 };

    // Computer Vision state
    let cvEnabled = false, cvReady = false, pose = null;
    let cvLane = 1, smoothX = 0.5;
    const video = document.getElementById('cam');
    const poseCanvas = document.getElementById('pose');
    const poseCtx = poseCanvas.getContext('2d');
    const cvStatus = document.getElementById('cvStatus');
    const cvToggle = document.getElementById('cvToggle');
    const camWrap = document.getElementById('camWrap');
    const calNote = document.getElementById('calNote');
    const calibrateDiv = document.getElementById('calibrate');
    const zoneL = document.getElementById('zL');
    const zoneC = document.getElementById('zC');
    const zoneR = document.getElementById('zR');
    const helpBtn = document.getElementById('helpBtn');
    const help = document.getElementById('help');
    const helpText = document.getElementById('helpText');
    const helpPrev = document.getElementById('helpPrev');
    const helpNext = document.getElementById('helpNext');
    const helpClose = document.getElementById('helpClose');

    // Calibration - 3 zones: LEFT | MIDDLE | RIGHT
    let calibrated = false, calibrating = false, calStep = 0;
    let calData = { leftX: 0.7, middleX: 0.5, rightX: 0.3 }; // Raw X positions (not mirrored)
    let calSamples = [], calTimer = 0;

    // Calibration: step 0=middle, 1=left, 2=right
    const CAL_STEPS = ['middle', 'left', 'right'];
    const CAL_ICONS = ['üßç', 'üëà üßç', 'üßç üëâ'];
    const CAL_INSTRS = ['Stand in MIDDLE', 'Step to YOUR LEFT', 'Step to YOUR RIGHT'];

    function initCV() {
      cvStatus.textContent = 'üì∑ Initializing...';

      pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
      pose.setOptions({ modelComplexity: 0, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
      pose.onResults(onPoseResults);

      navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 320, height: 240 } })
        .then(stream => {
          video.srcObject = stream;
          video.onloadedmetadata = () => {
            poseCanvas.width = video.videoWidth;
            poseCanvas.height = video.videoHeight;
            camWrap.style.display = 'block';
            cvStatus.textContent = 'üì∑ Ready! Starting calibration...';
            cvReady = true;
            cvToggle.textContent = 'üì∑ CV: ON';
            cvToggle.style.background = 'rgba(39,174,96,0.3)';
            cvToggle.style.borderColor = 'rgba(39,174,96,0.5)';
            setTimeout(() => startCalibration(), 500);
            detectPose();
          };
        })
        .catch(err => {
          cvStatus.textContent = '‚ùå Camera denied';
          console.error(err);
        });
    }

    function startCalibration() {
      calibrating = true;
      calibrated = false;
      calStep = 0;
      calSamples = [];
      calTimer = 0;
      calibrateDiv.style.display = 'flex';
      updateCalibrationUI();
      if (calNote) calNote.style.display = 'block';
    }

    function updateCalibrationUI() {
      document.getElementById('calStep').textContent = CAL_ICONS[calStep];
      document.getElementById('calInstr').textContent = CAL_INSTRS[calStep];
      document.getElementById('calBar').style.width = '0%';
    }

    function finishCalibration() {
      calibrating = false;
      calibrated = true;
      calibrateDiv.style.display = 'none';
      if (calNote) calNote.style.display = 'none';

      // Calculate thresholds between zones
      // leftX is when user is on their left (high X in raw video due to mirror)
      // rightX is when user is on their right (low X in raw video)
      calData.thresh1 = (calData.leftX + calData.middleX) / 2;   // between left and middle
      calData.thresh2 = (calData.middleX + calData.rightX) / 2;  // between middle and right

      cvStatus.innerHTML = '‚úÖ Calibrated! Move to change lanes';
    }

    document.getElementById('calSkip').onclick = () => {
      // Default: wider zones for easier detection
      calData = { leftX: 0.72, middleX: 0.5, rightX: 0.28, thresh1: 0.61, thresh2: 0.39 };
      finishCalibration();
    };

    document.getElementById('calReset').onclick = () => {
      startCalibration();
    };

    async function detectPose() {
      if (!cvEnabled || !cvReady) return;
      await pose.send({ image: video });
      requestAnimationFrame(detectPose);
    }

    function onPoseResults(results) {
      poseCtx.clearRect(0, 0, poseCanvas.width, poseCanvas.height);
      const w = poseCanvas.width, h = poseCanvas.height;

      // Draw 3 zone backgrounds
      if (calibrated) {
        poseCtx.globalAlpha = 0.25;
        // In mirrored view: left zone appears on screen-right, right zone on screen-left
        // Zone 1: LEFT (user's left = high X = screen right when mirrored)
        poseCtx.fillStyle = '#3498db';
        poseCtx.fillRect(0, 0, w * (1 - calData.thresh1), h);
        // Zone 2: MIDDLE
        poseCtx.fillStyle = '#27ae60';
        poseCtx.fillRect(w * (1 - calData.thresh1), 0, w * (calData.thresh1 - calData.thresh2), h);
        // Zone 3: RIGHT (user's right = low X = screen left when mirrored)
        poseCtx.fillStyle = '#e74c3c';
        poseCtx.fillRect(w * (1 - calData.thresh2), 0, w * calData.thresh2, h);
        poseCtx.globalAlpha = 1;
      }

      if (results.poseLandmarks) {
        drawConnectors(poseCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#ffd700', lineWidth: 2 });
        drawLandmarks(poseCtx, results.poseLandmarks, { color: '#ff6b6b', lineWidth: 1, radius: 4 });

        const lm = results.poseLandmarks;
        const lShoulder = lm[11], rShoulder = lm[12];
        const lHip = lm[23], rHip = lm[24];
        const lWrist = lm[15], rWrist = lm[16];

        // Body center X (average of shoulders for horizontal position)
        const bodyX = (lShoulder.x + rShoulder.x) / 2;
        const shoulderY = (lShoulder.y + rShoulder.y) / 2;
        const hipY = (lHip.y + rHip.y) / 2;

        // Smooth position (faster response)
        smoothX = smoothX * 0.05 + bodyX * 0.95;

        // Draw position indicator (vertical line)
        poseCtx.strokeStyle = '#ffd700';
        poseCtx.lineWidth = 3;
        poseCtx.beginPath();
        poseCtx.moveTo(w * (1 - smoothX), 0);
        poseCtx.lineTo(w * (1 - smoothX), h);
        poseCtx.stroke();

        // Calibration mode
        if (calibrating) {
          calSamples.push(bodyX);
          calTimer++;
          document.getElementById('calBar').style.width = (calTimer / 45 * 100) + '%';

          if (calTimer >= 45) {
            const avg = calSamples.reduce((a, b) => a + b, 0) / calSamples.length;

            if (calStep === 0) calData.middleX = avg;
            else if (calStep === 1) calData.leftX = avg;
            else if (calStep === 2) calData.rightX = avg;

            calStep++;
            calSamples = [];
            calTimer = 0;

            if (calStep >= 3) {
              finishCalibration();
            } else {
              updateCalibrationUI();
            }
          }
          return;
        }

        if (!calibrated) return;

        // Determine lane from position with center bias + hysteresis
        // Higher X = user moved to their LEFT (camera shows them on right)
        const centerBias = 0.1;       // wider middle zone
        const hysteresis = 0.015;     // reduce flicker at boundaries
        const middleSnap = 0.035;     // snap to middle when near center
        const leftThresh = calData.thresh1;
        const rightThresh = calData.thresh2;
        const centerMin = rightThresh + centerBias;
        const centerMax = leftThresh - centerBias;
        let newLane = cvLane;
        if (Math.abs(smoothX - calData.middleX) < middleSnap) {
          newLane = 1; // MIDDLE lane
        } else if (smoothX > leftThresh + hysteresis) {
          newLane = 0; // LEFT lane
        } else if (smoothX < rightThresh - hysteresis) {
          newLane = 2; // RIGHT lane
        } else if (smoothX >= centerMin && smoothX <= centerMax) {
          newLane = 1; // MIDDLE lane
        } else if (cvLane === 1) {
          if (smoothX > leftThresh) newLane = 0;
          else if (smoothX < rightThresh) newLane = 2;
        }

        // Update zone indicator UI
        zoneL.style.background = newLane === 0 ? '#3498db' : '#1a3a4a';
        zoneL.style.transform = newLane === 0 ? 'scale(1.1)' : 'scale(1)';
        zoneC.style.background = newLane === 1 ? '#27ae60' : '#1a4a2a';
        zoneC.style.transform = newLane === 1 ? 'scale(1.1)' : 'scale(1)';
        zoneR.style.background = newLane === 2 ? '#e74c3c' : '#4a1a1a';
        zoneR.style.transform = newLane === 2 ? 'scale(1.1)' : 'scale(1)';

        // Apply lane change in game
        if (st === 'play' && pl.tl !== newLane) {
          pl.tl = newLane;
          pl.lt = 0;
          cvLane = newLane;
        }

        // Arms up = Jump
        const armsUp = lWrist.y < lShoulder.y - 0.12 && rWrist.y < rShoulder.y - 0.12;
        // Crouch = Slide
        const bodyHeight = hipY - shoulderY;
        const isCrouching = bodyHeight < 0.2;

        const laneNames = ['‚óÄ LEFT', '‚óè MIDDLE', 'RIGHT ‚ñ∂'];
        const laneEmoji = ['üîµ', 'üü¢', 'üî¥'];

        if (st === 'play') {
          if (armsUp && pl.y <= 0) {
            pl.vy = 14;
            cvStatus.textContent = '‚¨ÜÔ∏è JUMP!';
          } else if (isCrouching && !pl.sl) {
            pl.sl = 25;
            cvStatus.textContent = '‚¨áÔ∏è SLIDE!';
          } else {
            cvStatus.textContent = laneEmoji[newLane] + ' ' + laneNames[newLane];
          }
        } else {
          cvStatus.textContent = laneEmoji[newLane] + ' ' + laneNames[newLane];
        }
      }
    }

    // Toggle CV
    cvToggle.onclick = () => {
      cvEnabled = !cvEnabled;
      if (cvEnabled && !cvReady) {
        initCV();
      } else if (cvEnabled && cvReady) {
        cvToggle.textContent = 'üì∑ CV: ON';
        cvToggle.style.background = 'rgba(39,174,96,0.3)';
        cvToggle.style.borderColor = 'rgba(39,174,96,0.5)';
        camWrap.style.display = 'block';
        if (!calibrated) startCalibration();
        detectPose();
      } else {
        cvToggle.textContent = 'üì∑ CV: OFF';
        cvToggle.style.background = 'rgba(255,215,0,0.15)';
        cvToggle.style.borderColor = 'rgba(255,215,0,0.3)';
        camWrap.style.display = 'none';
        calibrateDiv.style.display = 'none';
        if (calNote) calNote.style.display = 'none';
      }
    };

    // Auto-start CV on load (before game starts)
    window.addEventListener('load', () => {
      showHelp(0); // Auto-open help
      document.getElementById('hscDisplay').textContent = 'BEST: ' + bs.toString().padStart(6, '0');
      if (!cvEnabled) {
        cvEnabled = true;
        cvToggle.textContent = 'üì∑ CV: ON';
        cvToggle.style.background = 'rgba(39,174,96,0.3)';
        cvToggle.style.borderColor = 'rgba(39,174,96,0.5)';
        initCV();
      }
    });

    onkeydown = e => { ky[e.key] = 1; if (e.key === 'Escape' || e.key === 'p') { st === 'play' ? pause() : st === 'pause' ? resume() : 0 } if (e.key === 'c' && cvEnabled && cvReady) startCalibration(); e.preventDefault() };
    onkeyup = e => ky[e.key] = 0;
    const inp = d => { if (st !== 'play') return; if (d === 'l' && pl.tl > 0) { pl.tl--; pl.lt = 0 } if (d === 'r' && pl.tl < 2) { pl.tl++; pl.lt = 0 } if (d === 'u' && pl.y <= 0) pl.vy = 14; if (d === 'd' && !pl.sl) pl.sl = 25 };

    C.ontouchstart = e => { const t = e.touches[0]; tc.sx = tc.x = t.clientX; tc.sy = tc.y = t.clientY; tc.on = 1; if (st === 'menu') go() };
    C.ontouchmove = e => { const t = e.touches[0]; tc.x = t.clientX; tc.y = t.clientY };
    C.ontouchend = () => { if (!tc.on) return; const dx = tc.x - tc.sx, dy = tc.y - tc.sy; if (Math.abs(dx) > 30 || Math.abs(dy) > 30) Math.abs(dx) > Math.abs(dy) ? inp(dx > 0 ? 'r' : 'l') : inp(dy > 0 ? 'd' : 'u'); tc.on = 0 };

    document.getElementById('bl').onclick = () => inp('l'); document.getElementById('br').onclick = () => inp('r');
    document.getElementById('bu').onclick = () => inp('u'); document.getElementById('bd').onclick = () => inp('d');
    document.getElementById('st').onclick = go; document.getElementById('rt').onclick = go;
    document.getElementById('ps').onclick = pause; document.getElementById('rs').onclick = resume;
    document.getElementById('qt').onclick = () => { st = 'menu'; document.getElementById('pa').style.display = 'none'; document.getElementById('ps').style.display = 'none'; document.getElementById('m').style.display = 'flex'; cvToggle.style.display = 'none' };

    // Help/instructions
    const helpSteps = [
      '‚ö†Ô∏è IMPORTANT: Computer Vision requires Wi-Fi! If it hangs, REFRESH the page.',
      'CONTROLS: Swipe Left/Right to move, Up to Jump, Down to Crouch.',
      'CV TOGGLE: Click "CV: ON/OFF" (Top Right) to enable/disable camera & body control.',
      'ACTIONS: Arms Up = Jump. Crouch = Slide. Press C to recalibrate.'
    ];
    let helpIdx = 0;
    function showHelp(i) {
      helpIdx = (i + helpSteps.length) % helpSteps.length;
      helpText.textContent = helpSteps[helpIdx];
      help.style.display = 'flex';
    }
    helpBtn.onclick = () => showHelp(0);
    helpPrev.onclick = () => showHelp(helpIdx - 1);
    helpNext.onclick = () => showHelp(helpIdx + 1);
    helpClose.onclick = () => { help.style.display = 'none'; };

    function go() {
      if (cvEnabled && !calibrated) {
        startCalibration();
        return;
      }
      st = 'play'; sc = cn = 0; lv = 2; sp = 6; pl = { l: 1, tl: 1, lt: 1, y: 0, vy: 0, sl: 0, x: 0 }; ob = []; co = []; pt = []; tk = nx = 50; cvLane = 1;
      document.getElementById('m').style.display = 'none'; document.getElementById('ov').style.display = 'none'; document.getElementById('pa').style.display = 'none'; document.getElementById('ps').style.display = 'flex'; cvToggle.style.display = 'flex'; ui()
    }

    function pause() { if (st === 'play') { st = 'pause'; document.getElementById('pa').style.display = 'flex'; document.getElementById('ps').style.display = 'none' } }
    function resume() { if (st === 'pause') { st = 'play'; document.getElementById('pa').style.display = 'none'; document.getElementById('ps').style.display = 'flex' } }

    function gg() {
      st = 'over'; if (sc > bs) { bs = sc; localStorage.rb3 = bs }
      document.getElementById('fn').textContent = sc.toString().padStart(6, '0');
      document.getElementById('hsc').textContent = 'Best: ' + bs.toString().padStart(6, '0');
      document.getElementById('hscDisplay').textContent = 'BEST: ' + bs.toString().padStart(6, '0'); // Update top bar best
      document.getElementById('ov').style.display = 'flex'; document.getElementById('ps').style.display = 'none'
    }

    const ui = () => {
      document.getElementById('sc').textContent = sc.toString().padStart(6, '0');
      document.getElementById('cn').textContent = cn;
      document.getElementById('lv').innerHTML = '<span class="heartIcon">‚ô•</span>'.repeat(lv);
      // Update best score live if current score exceeds it
      const currentBest = Math.max(sc, bs);
      document.getElementById('hscDisplay').textContent = 'BEST: ' + currentBest.toString().padStart(6, '0');
    };

    function spn() {
      const t = ['t', 'b', 'w'][Math.random() * 3 | 0], l = Math.random() * 3 | 0, z = 900, cl = ['#e74c3c', '#3498db', '#27ae60', '#9b59b6', '#f39c12'];
      if (t === 't') { ob.push({ t, l, z, c: cl[Math.random() * 5 | 0] }); if (Math.random() < .15 && l < 2) ob.push({ t, l: l + 1, z, c: cl[Math.random() * 3 | 0] }) }
      else ob.push({ t, l, z }); if (Math.random() < .7) { const cl = Math.random() * 3 | 0; for (let i = 0; i < 5; i++)co.push({ l: cl, z: z + i * 35 }) }
    }

    const ap = (x, y, z, c, n) => { for (let i = 0; i < n; i++)pt.push({ x, y, z, vx: (Math.random() - .5) * 6, vy: Math.random() * 8, vz: (Math.random() - .5) * 4, lf: 25, c }) };

    function upd() {
      if (sh > 0) sh--; // Move shake decay here so it runs even if game over
      if (st !== 'play') return; tk++; sc += Math.ceil(sp / 2); if (tk % 120 === 0) sp = Math.min(12, sp + .15);
      if (ky.ArrowLeft || ky.a) { inp('l'); ky.ArrowLeft = ky.a = 0 } if (ky.ArrowRight || ky.d) { inp('r'); ky.ArrowRight = ky.d = 0 }
      if (ky.ArrowUp || ky.w || ky[' ']) inp('u'); if (ky.ArrowDown || ky.s) inp('d');
      pl.vy -= .7; pl.y += pl.vy; if (pl.y < 0) { pl.y = 0; pl.vy = 0 } if (pl.sl > 0) pl.sl--;
      pl.lt = Math.min(1, pl.lt + .15); pl.x = LN[pl.l] + (LN[pl.tl] - LN[pl.l]) * (1 - Math.pow(1 - pl.lt, 3)); if (pl.lt >= 1) pl.l = pl.tl;
      rz = (rz + sp) % 50; if (--nx <= 0) { spn(); nx = 55 + Math.random() * 35 - sp * .3 }
      for (let i = ob.length - 1; i >= 0; i--) {
        const o = ob[i]; o.z -= sp; if (o.z < -50) { ob.splice(i, 1); continue }
        if (o.z < 60 && o.z > -20 && Math.abs(LN[o.l] - pl.x) < 35) {
          if (o.t === 'w' && (pl.sl > 0 || pl.y > 25)) continue; if (o.t === 'b' && pl.y > 50) continue;
          sh = 10; ap(pl.x, 40, 30, '#ff4757', 15); lv--; ui(); ob.splice(i, 1); if (lv <= 0) return gg()
        }
      }
      for (let i = co.length - 1; i >= 0; i--) {
        const c = co[i]; c.z -= sp; if (c.z < -50) { co.splice(i, 1); continue }
        if (!c.g && c.z < 50 && c.z > -10 && Math.abs(LN[c.l] - pl.x) < 40 && pl.y < 60) { c.g = 1; cn++; sc += 20; ap(LN[c.l], 30, c.z, '#ffd700', 8); ui() }
      }
      for (let i = pt.length - 1; i >= 0; i--) { const p = pt[i]; p.x += p.vx; p.y += p.vy; p.z -= sp * .5; p.vy -= .4; if (--p.lf <= 0) pt.splice(i, 1) }
    }

    function drw() {
      X.save(); if (sh) X.translate((Math.random() - .5) * sh, (Math.random() - .5) * sh);
      const sky = X.createLinearGradient(0, 0, 0, HY + 50); sky.addColorStop(0, '#0d0d1a'); sky.addColorStop(1, '#1a1a3e'); X.fillStyle = sky; X.fillRect(0, 0, W, HY + 50);
      X.fillStyle = 'rgba(255,255,255,0.6)'; for (let i = 0; i < 40; i++)X.fillRect((i * 67 + tk * .02) % W, (i * 41) % (HY - 20), 1 + i % 2, 1);
      X.fillStyle = '#fffae6'; X.beginPath(); X.arc(320, 55, 22, 0, Math.PI * 2); X.fill();
      X.fillStyle = '#151528'; for (let i = 0; i < 14; i++) { const bh = 25 + Math.sin(i * 1.7) * 20 + Math.cos(i) * 15; X.fillRect(i * 30, HY - bh + 10, 22, bh + 40) }
      const gnd = X.createLinearGradient(0, HY, 0, H); gnd.addColorStop(0, '#252545'); gnd.addColorStop(1, '#151528'); X.fillStyle = gnd; X.fillRect(0, HY, W, H - HY);

      for (let z = 800; z >= 0; z -= 25) {
        const l1 = pj(-130, 0, z), r1 = pj(130, 0, z), l2 = pj(-130, 0, z + 25), r2 = pj(130, 0, z + 25);
        X.fillStyle = ((z + rz | 0) / 25) % 2 < 1 ? '#1a1a35' : '#1e1e3a'; X.beginPath(); X.moveTo(l1.x, l1.y); X.lineTo(r1.x, r1.y); X.lineTo(r2.x, r2.y); X.lineTo(l2.x, l2.y); X.fill();
        if (((z + rz | 0) / 25) % 2 < 1) { X.fillStyle = '#3a3a5a'; const sl = pj(-100, 0, z + 12), sr = pj(100, 0, z + 12); X.fillRect(sl.x, sl.y - 2, sr.x - sl.x, Math.max(2, sl.s * 6)) }
        X.strokeStyle = '#5a5a7a'; X.lineWidth = Math.max(1, l1.s * 4);
        for (let ln = 0; ln < 3; ln++) {
          const lx = LN[ln], rl1 = pj(lx - 22, 0, z), rl2 = pj(lx - 22, 0, z + 25), rr1 = pj(lx + 22, 0, z), rr2 = pj(lx + 22, 0, z + 25);
          X.beginPath(); X.moveTo(rl1.x, rl1.y); X.lineTo(rl2.x, rl2.y); X.stroke(); X.beginPath(); X.moveTo(rr1.x, rr1.y); X.lineTo(rr2.x, rr2.y); X.stroke()
        }
      }

      const all = [...ob, ...co.filter(c => !c.g), ...pt].sort((a, b) => b.z - a.z);
      for (const o of all) {
        if (o.t) {
          const p = pj(LN[o.l], 0, o.z), s = p.s; if (s < .05) continue;
          if (o.t === 't') {
            const w = s * 70, h = s * 100; X.fillStyle = 'rgba(0,0,0,0.4)'; X.beginPath(); X.ellipse(p.x, p.y + s * 5, w / 2, s * 15, 0, 0, Math.PI * 2); X.fill();
            const tg = X.createLinearGradient(p.x - w / 2, 0, p.x + w / 2, 0); tg.addColorStop(0, lt(o.c, -20)); tg.addColorStop(.5, lt(o.c, 20)); tg.addColorStop(1, lt(o.c, -20));
            X.fillStyle = tg; rr(p.x - w / 2, p.y - h, w, h, s * 8); X.fillStyle = lt(o.c, -35); X.fillRect(p.x - w / 2 + s * 3, p.y - h, w - s * 6, h * .08);
            X.fillStyle = 'rgba(180,220,255,0.85)'; for (let wy = p.y - h + h * .15; wy < p.y - h * .25; wy += h * .28) { rr(p.x - w / 2 + w * .08, wy, w * .38, h * .18, s * 2); rr(p.x + w * .04, wy, w * .38, h * .18, s * 2) }
            if (o.z < 400) { X.fillStyle = `rgba(255,255,100,${Math.min(1, (400 - o.z) / 200)})`; X.beginPath(); X.arc(p.x - w * .25, p.y - h * .08, s * 5, 0, Math.PI * 2); X.fill(); X.beginPath(); X.arc(p.x + w * .25, p.y - h * .08, s * 5, 0, Math.PI * 2); X.fill() }
          }
          else if (o.t === 'b') { const w = s * 80, h = s * 50; X.fillStyle = '#555'; X.fillRect(p.x - w / 2, p.y - h, s * 8, h); X.fillRect(p.x + w / 2 - s * 8, p.y - h, s * 8, h); X.fillStyle = '#f33'; X.fillRect(p.x - w / 2, p.y - h, w, h * .35); X.fillStyle = '#fff'; for (let i = 0; i < 6; i += 2)X.fillRect(p.x - w / 2 + i * w / 6, p.y - h, w / 6, h * .35) }
          else { const w = s * 70, h = s * 30; X.fillStyle = '#e67e22'; X.fillRect(p.x - w / 2, p.y - h, w, h); X.fillStyle = '#d35400'; X.fillRect(p.x - w / 2, p.y - h * .3, w, h * .3) }
        }
        else if (o.l !== undefined && !o.g) {
          const p = pj(LN[o.l], 35, o.z), r = Math.max(4, p.s * 14); X.save(); X.translate(p.x, p.y); X.scale(Math.cos(Math.sin(tk * .12 + o.z * .01) * .2), 1);
          X.fillStyle = 'rgba(255,215,0,0.3)'; X.beginPath(); X.arc(0, 0, r * 1.5, 0, Math.PI * 2); X.fill();
          const cg = X.createRadialGradient(-r * .3, -r * .3, 0, 0, 0, r); cg.addColorStop(0, '#fff8b0'); cg.addColorStop(.5, '#ffd700'); cg.addColorStop(1, '#b8860b'); X.fillStyle = cg; X.beginPath(); X.arc(0, 0, r, 0, Math.PI * 2); X.fill(); X.restore()
        }
        else if (o.lf) { const p = pj(o.x, o.y, o.z); if (p.s < .05) continue; X.globalAlpha = o.lf / 25; X.fillStyle = o.c; const sz = Math.max(2, p.s * 10); X.fillRect(p.x - sz / 2, p.y - sz / 2, sz, sz); X.globalAlpha = 1 }
      }

      const px = pj(pl.x, pl.y, 0), bb = Math.sin(tk * .35) * 2, S = 1.8; X.save(); X.translate(px.x, px.y);
      X.fillStyle = 'rgba(0,0,0,0.4)'; X.beginPath(); X.ellipse(0, 8, 20 * S, 6 * S, 0, 0, Math.PI * 2); X.fill();
      if (pl.sl > 0) { X.fillStyle = '#e74c3c'; rr(-20 * S, -10 * S, 40 * S, 15 * S, 5); X.fillStyle = '#fdbf6f'; X.beginPath(); X.arc(0, -15 * S, 9 * S, 0, Math.PI * 2); X.fill(); X.fillStyle = '#3498db'; rr(-6 * S, -22 * S, 12 * S, 5 * S, 2) }
      else {
        X.fillStyle = '#2c3e50'; X.fillRect(-11 * S, -25 * S + bb, 10 * S, 28 * S); X.fillRect(1 * S, -25 * S + bb, 10 * S, 28 * S);
        X.fillStyle = '#f1c40f'; rr(-14 * S, 2 * S + bb, 11 * S, 6 * S, 2); rr(3 * S, 2 * S + bb, 11 * S, 6 * S, 2);
        X.fillStyle = '#e74c3c'; rr(-15 * S, -58 * S + bb, 30 * S, 38 * S, 6); X.fillStyle = '#c0392b'; X.fillRect(-10 * S, -53 * S + bb, 20 * S, 8 * S);
        X.fillStyle = '#4a3728'; X.beginPath(); X.arc(0, -66 * S + bb, 13 * S, 0, Math.PI * 2); X.fill();
        X.fillStyle = '#3498db'; X.beginPath(); X.ellipse(0, -72 * S + bb, 14 * S, 5 * S, 0, 0, Math.PI * 2); X.fill()
      }
      X.restore();
      const fg = X.createLinearGradient(0, HY - 20, 0, HY + 80); fg.addColorStop(0, 'rgba(25,25,50,0.7)'); fg.addColorStop(1, 'rgba(25,25,50,0)'); X.fillStyle = fg; X.fillRect(0, HY - 20, W, 100); X.restore()
    }

    const rr = (x, y, w, h, r) => { X.beginPath(); X.roundRect(x, y, w, h, r); X.fill() };
    const lt = (c, p) => { const n = parseInt(c.slice(1), 16), r = Math.min(255, Math.max(0, (n >> 16) + p)), g = Math.min(255, Math.max(0, ((n >> 8) & 255) + p)), b = Math.min(255, Math.max(0, (n & 255) + p)); return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0') };

    (function lp() { upd(); drw(); requestAnimationFrame(lp) })();
  </script>
</body>

</html>